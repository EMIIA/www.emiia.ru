
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Display a map on a webpage</title>
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">

<script src="https://api.mapbox.com/mapbox-gl-js/v1.11.0/mapbox-gl.js"></script>


<link href="https://api.mapbox.com/mapbox-gl-js/v1.11.0/mapbox-gl.css" rel="stylesheet">

<script src='https://api.mapbox.com/mapbox.js/plugins/turf/v2.0.2/turf.min.js'></script> 

<script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>








<style>
body { margin: 0; padding: 0; }
#map { position: absolute; top: 0; bottom: 0; width: 100%; }
</style>
</head>






    <style>



*{margin:0;padding:0}body{font-family:-apple-system,Montserrat, montserrat;font-size:14px;font-weight:280;line-height:1.5}.is-loading{position:fixed;right:0;bottom:0;height:100%;text-align:center;color:#536580;text-shadow:0 2px 2px hsla(0,0%,100%,.4);

a { 
    text-decoration: none; /* Отменяем подчеркивание у ссылки */
   } 




background:hsla(0,0%,100%,.6);font-size:1.5rem;z-index:99999}.app-info,.is-loading{top:0;left:0;width:100%}.app-info{display:block;position:absolute;margin:0;padding:.5rem .75rem;background-color:transparent;color:#2b3441;

z-index:1!important;box-sizing:border-box}.app-info *{text-shadow:0 2px 3px hsla(0,0%,100%,.6),0 -2px 3px hsla(0,0%,100%,.6)}.app-info h1{font-size:1rem;margin:.2rem 0;font-weight:400}

.app-info h1 .lang-en{display:block;font-size:.875rem}.app-info p{font-size:.75rem;color:#545d6a}.app-info a{color:#536580;text-decoration:none}.app-info a:focus,.app-info a:hover{color:#495971;text-decoration:underline}.language-toggle-button{position:absolute;right:.75rem;top:.5rem;-webkit-appearance:none;padding:.5rem .75rem;color:#536580;background:hsla(0,0%,100%,.8);border:0;border-radius:4px;text-shadow:none;font-size:.75rem}.language-toggle-button:focus,.language-toggle-button:hover{color:#495971;background-color:#fff}.wrapper[lang*=zh-] [lang=en],.wrapper[lang=en] [lang*=zh-]{display:none}.mapContainer{position:absolute;top:0;left:0;right:0;bottom:0;width:100vw;height:100vh}.marker{background-image:url(/images/pin.svg);background-size:auto 100%;width:32px;height:32px;cursor:pointer}


.mapboxgl-popup-content:not(:empty){box-shadow:0 0 10px 2px rgba(0,0,0,.1)}





.mapboxgl-popup-content{font-size:1rem;font-weight: 100;border-radius:7px;padding:1rem;width:321px}[lang=en]





.mapboxgl-popup-content{min-width:380px}.mapboxgl-popup .tag{font-size:.875rem;color:#545d6a;line-height:1.2}
.mapboxgl-popup .tag[lang=en]{font-size:.75rem}.mapboxgl-popup h3{color:#2b3441;margin:.5rem 0;text-transform:capitalize;line-height:1.2}.mapboxgl-popup h3[lang=en]{font-size:.875rem}.mapboxgl-popup p{font-size:.875rem;color:#545d6a;margin-bottom:.25rem}.mapboxgl-popup p[lang=en]{font-size:.875rem}.mapboxgl-popup .divider{color:#efefef}

.mapboxgl-popup a{color:#3D85C6;text-decoration:none}.mapboxgl-popup a:focus,.mapboxgl-popup a:hover{color:#3D85C6;text-decoration:none}.mapboxgl-popup-close-button{font-size:.0rem;padding:.0rem}
/*# sourceMappingURL=main.9498309c.chunk.css.map */





a.mapboxgl-ctrl-logo{
    width: 0;
    height: 0;
    margin: 0 0 -4px-4px;
    display: block;
    background-repeat: no-repeat;
    cursor: pointer;
    overflow: hidden;
    background-image: url(data:image/svg+xml;charset=utf-8,%3Csvg width='88' height='23' viewBox='0 0 88 23' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' fill-rule='evenodd'%3E %3Cdefs%3E %3Cpath id='logo' d='M11.5 2.25c5.105 0 9.25 4.145 9.25 9.25s-4.145 9.25-9.25 9.25-9.25-4.145-9.25-9.25 4.145-9.25 9.25-9.25zM6.997 15.983c-.051-.338-.828-5.802 2.233-8.873a4.395 4.395 0 013.13-1.28c1.27 0 2.49.51 3.39 1.42.91.9 1.42 2.12 1.42 3.39 0 1.18-.449 2.301-1.28 3.13C12.72 16.93 7 16 7 16l-.003-.017zM15.3 10.5l-2 .8-.8 2-.8-2-2-.8 2-.8.8-2 .8 2 2 .8z'/%3E %3Cpath id='text' d='M50.63 8c.13 0 .23.1.23.23V9c.7-.76 1.7-1.18 2.73-1.18 2.17 0 3.95 1.85 3.95 4.17s-1.77 4.19-3.94 4.19c-1.04 0-2.03-.43-2.74-1.18v3.77c0 .13-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V8.23c0-.12.1-.23.23-.23h1.4zm-3.86.01c.01 0 .01 0 .01-.01.13 0 .22.1.22.22v7.55c0 .12-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V15c-.7.76-1.69 1.19-2.73 1.19-2.17 0-3.94-1.87-3.94-4.19 0-2.32 1.77-4.19 3.94-4.19 1.03 0 2.02.43 2.73 1.18v-.75c0-.12.1-.23.23-.23h1.4zm26.375-.19a4.24 4.24 0 00-4.16 3.29c-.13.59-.13 1.19 0 1.77a4.233 4.233 0 004.17 3.3c2.35 0 4.26-1.87 4.26-4.19 0-2.32-1.9-4.17-4.27-4.17zM60.63 5c.13 0 .23.1.23.23v3.76c.7-.76 1.7-1.18 2.73-1.18 1.88 0 3.45 1.4 3.84 3.28.13.59.13 1.2 0 1.8-.39 1.88-1.96 3.29-3.84 3.29-1.03 0-2.02-.43-2.73-1.18v.77c0 .12-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V5.23c0-.12.1-.23.23-.23h1.4zm-34 11h-1.4c-.13 0-.23-.11-.23-.23V8.22c.01-.13.1-.22.23-.22h1.4c.13 0 .22.11.23.22v.68c.5-.68 1.3-1.09 2.16-1.1h.03c1.09 0 2.09.6 2.6 1.55.45-.95 1.4-1.55 2.44-1.56 1.62 0 2.93 1.25 2.9 2.78l.03 5.2c0 .13-.1.23-.23.23h-1.41c-.13 0-.23-.11-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.8 0-1.46.7-1.59 1.62l.01 4.68c0 .13-.11.23-.23.23h-1.41c-.13 0-.23-.11-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.85 0-1.54.79-1.6 1.8v4.5c0 .13-.1.23-.23.23zm53.615 0h-1.61c-.04 0-.08-.01-.12-.03-.09-.06-.13-.19-.06-.28l2.43-3.71-2.39-3.65a.213.213 0 01-.03-.12c0-.12.09-.21.21-.21h1.61c.13 0 .24.06.3.17l1.41 2.37 1.4-2.37a.34.34 0 01.3-.17h1.6c.04 0 .08.01.12.03.09.06.13.19.06.28l-2.37 3.65 2.43 3.7c0 .05.01.09.01.13 0 .12-.09.21-.21.21h-1.61c-.13 0-.24-.06-.3-.17l-1.44-2.42-1.44 2.42a.34.34 0 01-.3.17zm-7.12-1.49c-1.33 0-2.42-1.12-2.42-2.51 0-1.39 1.08-2.52 2.42-2.52 1.33 0 2.42 1.12 2.42 2.51 0 1.39-1.08 2.51-2.42 2.52zm-19.865 0c-1.32 0-2.39-1.11-2.42-2.48v-.07c.02-1.38 1.09-2.49 2.4-2.49 1.32 0 2.41 1.12 2.41 2.51 0 1.39-1.07 2.52-2.39 2.53zm-8.11-2.48c-.01 1.37-1.09 2.47-2.41 2.47s-2.42-1.12-2.42-2.51c0-1.39 1.08-2.52 2.4-2.52 1.33 0 2.39 1.11 2.41 2.48l.02.08zm18.12 2.47c-1.32 0-2.39-1.11-2.41-2.48v-.06c.02-1.38 1.09-2.48 2.41-2.48s2.42 1.12 2.42 2.51c0 1.39-1.09 2.51-2.42 2.51z'/%3E %3C/defs%3E %3Cmask id='clip'%3E %3Crect x='0' y='0' width='100%25' height='100%25' fill='white'/%3E %3Cuse xlink:href='%23logo'/%3E %3Cuse xlink:href='%23text'/%3E %3C/mask%3E %3Cg id='outline' opacity='0.3' stroke='%23000' stroke-width='3'%3E %3Ccircle mask='url(%23clip)' cx='11.5' cy='11.5' r='9.25'/%3E %3Cuse xlink:href='%23text' mask='url(%23clip)'/%3E %3C/g%3E %3Cg id='fill' opacity='0.9' fill='%23fff'%3E %3Cuse xlink:href='%23logo'/%3E %3Cuse xlink:href='%23text'/%3E %3C/g%3E %3C/svg%3E);
}

  








.mapboxgl-popup {
    z-index: 1;

}






.marker svg {
  width: 100%;
  height: 100%;
}
.marker{
  pointer-events:none;
}











/* Bottom emiia левый ряд включая кнопки INDOOR отступы*/

.mapboxgl-ctrl-bottom-left .mapboxgl-ctrl {
    margin: -1px -1px 10px 10px;
    float: left;
}


/* Bottom emiia нижний правый ряд включая кнопки INDOOR отступы*/
.mapboxgl-ctrl-bottom-right .mapboxgl-ctrl {
    margin: 10px 10px 25px 14px;
    float: right;
}







/* emiia размер боковых кнопок */
.mapboxgl-ctrl-group button {
    width: 44.0px;
    height: 44.0px;
    display: block;

    padding: 0px;
    outline: none;
    border: 0;
    box-sizing: border-box;
    background-color: transparent;
    cursor: pointer;
    
       font: 13px/20px Montserrat, montserrat;
       
       color:#383838
    
  
}




















.mapboxgl-ctrl-scale {
    background-color: hsla(0,0%,100%,.75);
 
    border: 2px solid white;
    border-top: #333;
    border-radius: 4px;
    padding: 0 6px;
    color: #333;
    box-sizing: border-box;
  
    font: 10px/20px Montserrat, montserrat;
    font-weight: 400;
    max-width: 7em;
    max-height: 1.9em;

    box-shadow: 0 0 10px 2px rgb(0 0 0 / 10%);
}




.mapboxgl-popup-content {


    
    
     font: 12px/20px Montserrat, montserrat;

   border-radius: 12px;
    padding: 0.5rem;
    
    
    width: max-content;
    
    
    
    

}   
    
    
    
    
    
    
    
    






@import url('https://www.emiia.ru/css.css?family=Montserrat:100,100i,200,200i,300,300i,400,400i,500,500i,600,600i,700,700i,800,800i,900,900i&display=swap&subset=cyrillic');


  
@import url('/css.css?family=Montserrat:100,100i,200,200i,300,300i,400,400i,500,500i,600,600i,700,700i,800,800i,900,900i&display=swap&subset=cyrillic');

}




@import url("https://cdn.jsdelivr.net/npm/bootstrap-icons@1.9.1/font/bootstrap-icons.css");








</style>











<body>
<div id="map"></div>



<button id="replay" ></button>



<script>






	// import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r115/build/three.module.js';
	// import {OrbitControls} from 'https://threejsfundamentals.org/threejs/resources/threejs/r115/examples/jsm/controls/OrbitControls.js';
	// import {GLTFLoader} from 'https://threejsfundamentals.org/threejs/resources/threejs/r115/examples/jsm/loaders/GLTFLoader.js';
    










	// TO MAKE THE MAP APPEAR YOU MUST
	// ADD YOUR ACCESS TOKEN FROM
	// https://account.mapbox.com
	mapboxgl.accessToken = 'pk.eyJ1IjoiYXBlcnNoaW5hIiwiYSI6ImNsand2N2dxcjIxeHEzbW1qcWF1bGE1ZzAifQ.3SHiRIyN5OQIhQJxXAblZA';
    
    
    const map = new mapboxgl.Map({
        container: 'map', // container ID
        // Choose from Mapbox's core styles, or make your own style with Mapbox Studio
        style: 'mapbox://styles/emiiaai/ckv9cvgm062s515nz08d6ceq0', // style URL
        
         attributionControl: false,
        
        
        center: [37.174014151096344,
              55.97747745943937], // starting position [lng, lat]
        zoom: 18 // starting zoom
    });
    
    
    
    

    
map.addControl(new mapboxgl.NavigationControl({
  visualizePitch: true,
  showZoom: false
}));    
    
    
    
</script>






<script src='https://api.mapbox.com/mapbox.js/plugins/turf/v2.0.2/turf.min.js'></script> 

<script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>











     










<script src="https://cdn.jsdelivr.net/gh/jscastro76/threebox@v.2.2.2/dist/threebox.min.js" type="text/javascript"></script>
   
   
   
   <script src="https://cdnjs.cloudflare.com/ajax/libs/three.meshline/1.4.0/THREE.MeshLine.js" integrity="sha512-CNumL3RLkfw0m0RcHHv67JdGVqchvvNOPZnX9WP2gNzkyk82/jKCgK1kVGJV8U3Cr+mEFOFAxY6L63mUGj3TIA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
   
   
   
   
   
   <script type="x-shader/x-vertex" id="vertexShader">

			attribute vec3 center;
			varying vec3 vCenter;

			void main() {

				vCenter = center;

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}

		</script>
        
        
        
        
        
        
        
        
        
        

        
       
   
   
   
   
   
   
   


<script>




// parameters to ensure the model is georeferenced correctly on the map
var modelOrigin = [37.17409849995867,55.97737925266699]//[2.318, 48.850];
var modelAltitude = -0;
var modelRotate = [0.57, 0.16, -501.259];










   

var modelAsMercatorCoordinate = mapboxgl.MercatorCoordinate.fromLngLat(
  modelOrigin,
  modelAltitude
);





// transformation parameters to position, rotate and scale the 3D model onto the map
var modelTransform = {
  translateX: modelAsMercatorCoordinate.x,
  translateY: modelAsMercatorCoordinate.y,
  translateZ: modelAsMercatorCoordinate.z,
  rotateX: modelRotate[0],
  rotateY: modelRotate[1],
  rotateZ: modelRotate[2],
  /* Since our 3D model is in real world meters, a scale transform needs to be
   * applied since the CustomLayerInterface expects units in MercatorCoordinates.
   */
  scale: modelAsMercatorCoordinate.meterInMercatorCoordinateUnits()
};


























var THREE = window.THREE;

// configuration of the custom layer for a 3D model per the CustomLayerInterface
var customLayer = {
  id: "3d-model",
  type: "custom",
            wireframe: true,
  renderingMode: "3d",
  onAdd: function (map, gl) {
    this.camera = new THREE.Camera();
    this.scene = new THREE.Scene();
    
    
    
    
     // create two three.js lights to illuminate the model
    var directionalLight = new THREE.DirectionalLight(0xffffff);
    directionalLight.position.set(0, 0, 0).normalize();
    this.scene.add(directionalLight);

    var directionalLight2 = new THREE.DirectionalLight(0xffffff);
    directionalLight2.position.set(0, 0, 0).normalize();
    this.scene.add(directionalLight2);
    
    
    
    

    
    

    // use the three.js GLTF loader to add the 3D model to the three.js scene
    var loader = new THREE.OBJLoader();
    
    
    
    
    
    
    
    
    
    
    
             loader.load(
    "https://www.emiia.ru/relise/modeOBJ-5.obj" , 
    
    
 

      
    (mesh) => {
        
        
      
      
 // ?.     
                    
                                mesh.children[0].material = new THREE.MeshBasicMaterial({
    wireframe: false,
          color: 0xFFFFFF,
          opacity: 1,
          transparent: true,
          fog: false
        });
        
        
        
        // Контуры стен.
                    
                                mesh.children[1].material = new THREE.MeshBasicMaterial({
    wireframe: false,
          color: 0xFFFFFF,
          opacity: 1,
          transparent: true,
          fog: false
        });
        
        
        
        
        
        
         // Стены.     
                    
                                mesh.children[2].material = new THREE.MeshBasicMaterial({
    wireframe: false,
          color: 0xFFFFFF,
          opacity: 1,
          transparent: true,
          fog: false
        });
        
        
        
        
                 // ?.     
                    
                                mesh.children[3].material = new THREE.MeshBasicMaterial({
    wireframe: false,
          color: 0xFFFFFF,
          opacity: 1,
          transparent: true,
          fog: false
        });
        
        
        
        
        
                         // ?.     
                    
                                mesh.children[4].material = new THREE.MeshBasicMaterial({
    wireframe: false,
          color: 0xFFFFFF,
          opacity: 1,
          transparent: true,
          fog: false
        });
        
        
        
        
         // ?.     
                    
                                mesh.children[5].material = new THREE.MeshBasicMaterial({
    wireframe: false,
          color: 0xffFFFF,
          opacity: 1,
          transparent: true,
          fog: false
        });
        
        
        
        
        

        
      // Y.     
                    
                                mesh.children[6].material = new THREE.MeshBasicMaterial({
    wireframe: false,
          color: 0x66ff00,
          opacity: 1,
          transparent: true,
          fog: false
        });  
        



    
     // X.     
                    
                                mesh.children[7].material = new THREE.MeshBasicMaterial({
    wireframe: false,
          color: 0xff2400 ,
          opacity: 1,
          transparent: true,
          fog: false
        });  
    
    
    
    
    
    //Z.     
                    
                                mesh.children[8].material = new THREE.MeshBasicMaterial({
    wireframe: false,
          color: 0x3D85C6,
          opacity: 1,
          transparent: true,
          fog: false
        });  
        
        
        
        
        
        
         //Основная решетка.     
                    
                                mesh.children[9].material = new THREE.MeshBasicMaterial({
    wireframe: false,
          color: 0xFFFFFF,
          opacity: 1,
          transparent: true,
          fog: false
        });  
    
        
        
     
        
        this.scene.add(mesh);
      }
    );
    
    
    
    
    
    
    

    
    
   
      
    
    
    
    
    
    
    
    
    



    
     loader.load(
    "https://www.emiia.ru/relise/modeOBJ-2.obj" , 
    
    
   

      

      
    (mesh) => {
        
        
        
        
       
        
        
        
    
        

        
      
      
      
      
 // Лесничная площадка.     
                    
                                mesh.children[0].material = new THREE.MeshBasicMaterial({
    wireframe: false,
          color: 0xFFFFFF,
          opacity: 0.95,
          transparent: true,
          fog: false
        });
        
        
        
        
        
        
        // Верхние грани.     
                    
                                mesh.children[1].material = new THREE.MeshBasicMaterial({
    wireframe: false,
          color: 0xffFFFF,
          opacity: 1,
          transparent: true,
          fog: false
        });
        
        
        
        
        
        
        
        
        
             // Стены.     
                    
                                mesh.children[2].material = new THREE.MeshBasicMaterial({
    wireframe: false,
         color: 0xE8E8E8,
          opacity: 0.83,
          transparent: true,
          fog: false
        });
        
        
        
   
 
              // Внутренние грани наружных окон.     
                    
                                mesh.children[3].material = new THREE.MeshBasicMaterial({
    wireframe: false,
         color: 0xD3D3D3,
          opacity: 1,
          transparent: true,
          fog: false
        });
        
        
        
        
        
        
        
        
        
         
              // Унитаз и умывальник.     
                    
                                mesh.children[4].material = new THREE.MeshBasicMaterial({
    wireframe: false,
         color: 0xFFFFFF,
          opacity: 1,
          transparent: true,
          fog: false
        });
 
        
        
        
        
        
                    // Рамы внешних окон.     
                    
                                mesh.children[5].material = new THREE.MeshBasicMaterial({
    wireframe: false,
         color: 0xFFFFFF,
          opacity: 1,
          transparent: true,
          fog: false
        });
        
        
        
        
        
        
        
                            // Вертикальные ребра стен (стыки).     
                    
                                mesh.children[6].material = new THREE.MeshBasicMaterial({
    wireframe: false,
         color: 0xE8E8E8,
          opacity: 0.8,
          transparent: true,
          fog: false
        });
        
        
        
        
        
        
                                    //Смеситель.     
                    
                                mesh.children[7].material = new THREE.MeshBasicMaterial({
    wireframe: false,
         color: 0xFFffff,
          opacity: 1,
          transparent: true,
          fog: false
        });
        
        
  
  
  
  
  
                                      //Стекла окон на лестничных площадках.     
                    
                                mesh.children[8].material = new THREE.MeshBasicMaterial({
    wireframe: false,
         color: 0xFFFFFF,
          opacity: 0,
          transparent: true,
          fog: false
        });
        
        
        
        
        
        
        
        
        
        
         //Внутренние грани окон на лестничных площадках.
        
        
                                       mesh.children[9].material = new THREE.MeshBasicMaterial({
    wireframe: false,
         color: 0xD3D3D3,
          opacity: 1,
          transparent: true,
          fog: false
        });
        
        
        
        
        
        
        
        
        
        
        
        
        
                                             //Внутренние грани внешних окон.     
                    
                                mesh.children[10].material = new THREE.MeshBasicMaterial({
    wireframe: false,
         color: 0xD3D3D3,
          opacity: 1,
          transparent: true,
          fog: false
        });
        
        
        
        
                                                     //Стекла внешних окон.     
                    
                                mesh.children[11].material = new THREE.MeshBasicMaterial({
    wireframe: false,
         color: 0xD3D3D3,
          opacity: 0,
          transparent: true,
          fog: false
        });
        
        
        
        
  
  
  
  
  
  
  
  
    
                                      //Полотно внутренних дверей.     
                    
                                mesh.children[12].material = new THREE.MeshBasicMaterial({
    wireframe: false,
         color: 0xFFFFFF,
          opacity: 0.9,
          transparent: true,
          fog: false
        });
  
  
  
  
  
  
  
                                        //Внутренний наличник дверей внутри.     
                    
                                mesh.children[13].material = new THREE.MeshBasicMaterial({
    wireframe: false,
         color: 0xd3d3d3,
          opacity: 1,
          transparent: true,
          fog: false
        });
  
  
  
  
  
  
    
                                        //Внутренние двери (внутренние грани1).     
                    
                                mesh.children[14].material = new THREE.MeshBasicMaterial({
    wireframe: false,
         color: 0xD3D3D3,
          opacity: 1,
          transparent: true,
          fog: false
        });
  
  
  
  
  
  
  
  
  
      
                                        //Внутренние двери (внутренние грани2).     
                    
                                mesh.children[15].material = new THREE.MeshBasicMaterial({
    wireframe: false,
         color: 0xD3D3D3,
          opacity: 1,
          transparent: true,
          fog: false
        });
  
  
  
  
                                          //Пожарный оповещатель.     
                    
                                mesh.children[16].material = new THREE.MeshBasicMaterial({
    wireframe: false,
         color: 0xFFFFFF,
          opacity: 1,
          transparent: true,
          fog: false
        });
   
 
 
 
 
 
 
 

   
 
 
 
 
 
 
        
        
        this.scene.add(mesh);
      }
    );
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
   
    this.map = map;

    // use the Mapbox GL JS map canvas for three.js
    this.renderer = new THREE.WebGLRenderer({
      canvas: map.getCanvas(),
      context: gl,
                wireframe: true,
                
               
                
                
                
      antialias: true
    });
       
    
    

    

    
     this.renderer.autoClear = false;
  },
  render: function (gl, matrix) {
    var rotationX = new THREE.Matrix4().makeRotationAxis(
      new THREE.Vector3(0, 0, 0),
      modelTransform.rotateX
    );
    var rotationY = new THREE.Matrix4().makeRotationAxis(
      new THREE.Vector3(0, 0, 0),
      modelTransform.rotateY
    );
    var rotationZ = new THREE.Matrix4().makeRotationAxis(
      new THREE.Vector3(0, 0, 1),
      modelTransform.rotateZ
    );
    
    
    


    var m = new THREE.Matrix4().fromArray(matrix);
    var l = new THREE.Matrix4()
      .makeTranslation(
        modelTransform.translateX,
        modelTransform.translateY,
        modelTransform.translateZ
      )
      .scale(
        new THREE.Vector3(
          modelTransform.scale,
          -modelTransform.scale,
          modelTransform.scale
        )
      )
      .multiply(rotationX)
      .multiply(rotationY)
      .multiply(rotationZ);

    this.camera.projectionMatrix = m.multiply(l);
    this.renderer.resetState();
    this.renderer.render(this.scene, this.camera);
    this.map.triggerRepaint();
  }
};

    

   

map.on("style.load", () => {
  map.addLayer(customLayer, "waterway-label");
});






     

</script>
    
    



















    
    
    
    
    
    
    
    
    
    
   <script> 
    
 map.on('load', () => {
// Insert the layer beneath any symbol layer.
const layers = map.getStyle().layers;
const labelLayerId = layers.find(
(layer) => layer.type === 'symbol' && layer.layout['text-field']
).id;
 
// The 'building' layer in the Mapbox Streets
// vector tileset contains building height data
// from OpenStreetMap.
map.addLayer(
{
'id': 'add-3d-buildings',
'source': 'composite',
'source-layer': 'building',
'filter': ['==', 'extrude', 'true'],
'type': 'fill-extrusion',


'minzoom': 14,
'maxzoom': 19,



'paint': {
'fill-extrusion-color': '#aaa',
 
// Use an 'interpolate' expression to
// add a smooth transition effect to
// the buildings as the user zooms in.
'fill-extrusion-height': [
'interpolate',
['linear'],
['zoom'],
15,
0,
15.05,
['get', 'height']
],
'fill-extrusion-base': [
'interpolate',
['linear'],
['zoom'],
15,
0,
15.05,
['get', 'min_height']
],
'fill-extrusion-opacity': 0.2





}
},
labelLayerId
);
});



    
    
  </script> 

































































<script> 
    
 map.on('load', () => {
// Insert the layer beneath any symbol layer.
const layers = map.getStyle().layers;
const labelLayerId = layers.find(
(layer) => layer.type === 'symbol' && layer.layout['text-field']
).id;
 
// The 'building' layer in the Mapbox Streets
// vector tileset contains building height data
// from OpenStreetMap.
map.addLayer(
{
'id': 'add-3d-buildings',
'source': 'composite',
'source-layer': 'building',
'filter': ['==', 'extrude', 'true'],
'type': 'fill-extrusion',


'minzoom': 14,
'maxzoom': 19,



'paint': {
'fill-extrusion-color': '#aaa',
 
// Use an 'interpolate' expression to
// add a smooth transition effect to
// the buildings as the user zooms in.
'fill-extrusion-height': [
'interpolate',
['linear'],
['zoom'],
15,
0,
15.05,
['get', 'height']
],
'fill-extrusion-base': [
'interpolate',
['linear'],
['zoom'],
15,
0,
15.05,
['get', 'min_height']
],
'fill-extrusion-opacity': 0.2





}
},
labelLayerId
);
});



    
    
  </script> 
 
 

 

    
    

    
    


    
   
   
   
   
   
   
   
   
   
   
   
   

    
    
    
    
    
    
    
    
    
    
    
    
    


   
   
   
   
    
    
    
    
    
    
    

        
        
        
     
      
   
   
   
   
    
    
    
    

        
    
    
    
    
    
    

    
    
    
    
    
    
    
   <script>


 
// A simple line from origin to destination.
const route = {
'type': 'FeatureCollection',
'id': '888',
'features': [
{
'type': 'Feature',
'id': '888',
'geometry': {
'type': 'LineString',
'coordinates': [[37.17417951425341,55.97743710357804], [37.17415334020461,55.977424607030116], [37.17408685623059,55.977430543896844], [37.17405923582942,55.97735488266653],[37.1740015268208,55.97736016541478], [37.17405923582942,55.97735488266653], [37.17408685623059,55.977430543896844], [37.17415334020461,55.977424607030116],[37.17417951425341,55.97743710357804],[37.17415334020461,55.977424607030116], [37.17408685623059,55.977430543896844], [37.17405923582942,55.97735488266653],[37.1740015268208,55.97736016541478], [37.17405923582942,55.97735488266653], [37.17408685623059,55.977430543896844], [37.17415334020461,55.977424607030116],[37.17417951425341,55.97743710357804]]
}
}
]
};




// A single point that animates along the route.
// Coordinates are initially set to origin.
const point = {
'type': 'FeatureCollection',
'id': '888',
'features': [
{
'type': 'Feature',
'properties': {},
'geometry': {
'type': 'Point',



'coordinates': origin
}
}
]
};
 
// Calculate the distance in kilometers between route start/end point.
const lineDistance = turf.length(route.features[0]);
 
const arc = [];
 
// Number of steps to use in the arc and animation, more steps means
// a smoother arc and animation, but too many steps will result in a
// low frame rate
const steps = 300000;
 
// Draw an arc between the `origin` & `destination` of the two points
for (let i = 0; i < lineDistance; i += lineDistance / steps) {
const segment = turf.along(route.features[0], i);
arc.push(segment.geometry.coordinates);
}
 
// Update the route with calculated arc coordinates
route.features[0].geometry.coordinates = arc;
 
// Used to increment the value of the point measurement against the route.
let counter = 0;
 
map.on('load', () => {
// Add a source and layer displaying a point which will be animated in a circle.
map.addSource('route', {
'type': 'geojson',




'data': route
});








    



 
map.addSource('point', {
'type': 'geojson',

'data': point
});
 
map.addLayer({
'id': 'route',

'minzoom': 19,

'source': 'route',

'type': 'line',
'paint': {
'line-width': 8,


'line-color': '#3d85c6',







}






},'road-label-navigation');
 
map.addLayer({
'id': 'point',
'source': 'point',

'minzoom': 19,






'type': 'symbol',
'layout': {
// This icon is a part of the Mapbox Streets style.
// To view all images available in a Mapbox style, open
// the style in Mapbox Studio and click the "Images" tab.
// To add a new image to the style at runtime see
// https://docs.mapbox.com/mapbox-gl-js/example/add-image/




'icon-image': 'pulsing-dot',
'icon-size': 0.6,

'icon-rotate': ['get', 'bearing'],

'icon-allow-overlap': true,
'icon-ignore-placement': true
}
}, 'road-label-navigation');












function animate() {
const start =
route.features[0].geometry.coordinates[
counter >= steps ? counter - 0 : counter
];
const end =
route.features[0].geometry.coordinates[
counter >= steps ? counter : counter + 0
];
if (!start || !end) return;
 
// Update point geometry to a new position based on counter denoting
// the index to access the arc
point.features[0].geometry.coordinates =
route.features[0].geometry.coordinates[counter];
 
// Calculate the bearing to ensure the icon is rotated to match the route arc
// The bearing is calculated between the current point and the next point, except
// at the end of the arc, which uses the previous point and the current point
point.features[0].properties.bearing = turf.bearing(
turf.point(start),
turf.point(end)
);
 
// Update the source with this new data
map.getSource('point').setData(point);
 
// Request the next frame of animation as long as the end has not been reached
if (counter < steps) {
requestAnimationFrame(animate);
}
 
 
 

 
 
counter = counter + 30;
}
 
document.getElementById('replay').addEventListener('click', () => {
// Set the coordinates of the original point back to origin
point.features[0].geometry.coordinates = origin;
 
// Update the source layer
map.getSource('point').setData(point);
 
// Reset the counter
counter = 0;


 
// Restart the animation
animate(counter);
});
 
// Start the animation
animate(counter);
});





 
const size = 180;
 
// This implements `StyleImageInterface`
// to draw a pulsing dot icon on the map.
const pulsingDot = {
width: size,
height: size,
data: new Uint8Array(size * size * 4),
 
// When the layer is added to the map,
// get the rendering context for the map canvas.
onAdd: function () {
const canvas = document.createElement('canvas');
canvas.width = this.width;
canvas.height = this.height;
this.context = canvas.getContext('2d');
},
 
// Call once before every frame where the icon will be used.
render: function () {
const duration = 1000;
const t = (performance.now() % duration) / duration;
 
const radius = (size / 2) * 0.3;
const outerRadius = (size / 2) * 0.7 * t + radius;
const context = this.context;
 
// Draw the outer circle.
context.clearRect(0, 0, this.width, this.height);
context.beginPath();
context.arc(
this.width / 2,
this.height / 2,
outerRadius,
0,
Math.PI * 2
);
context.fillStyle = `rgba(61, 133, 198, ${1 - t})`;
context.fill();
 
// Draw the inner circle.
context.beginPath();
context.arc(
this.width / 2,
this.height / 2,
radius,
0,
Math.PI * 2
);
context.fillStyle = '#3d85c6';
context.strokeStyle = 'white';
context.lineWidth = 2 + 4 * (1 - t);
context.fill();
context.stroke();
 
// Update this image's data with data from the canvas.
this.data = context.getImageData(
0,
0,
this.width,
this.height
).data;
 
// Continuously repaint the map, resulting
// in the smooth animation of the dot.
map.triggerRepaint();
 
// Return `true` to let the map know that the image was updated.
return true;
}
};






 
map.on('load', () => {
map.addImage('pulsing-dot', pulsingDot, { pixelRatio: 2 });
 
map.addSource('dot-point', {
'type': 'geojson',
'data': {
'type': 'FeatureCollection',
'id': '888',
'features': [
{
'type': 'Feature',
'id': '888',
'geometry': {
'type': 'Point',
'coordinates': [0, 0] // icon position [lng, lat]
}
}
]
}
});





});




</script>

    
    
    
    
    
    
    
    
    
    
    
    
    <script>

var elevated_points= {
  "type": "FeatureCollection",
  "features": [
  


{
      "type": "Feature",
      "properties": {},
      "geometry": {
        "type": "Point",
        "coordinates": [
     37.17403983330939, 55.97740800874055
        ]
      }
    }
    
    
  ]
}

map.on('style.load', function(){
  map.addSource('projects', {
    'type': 'geojson',
    'data': elevated_points
  });




  function pulseMarker(timestamp){
    setTimeout(function() {
      requestAnimationFrame(pulseMarker)
      multiplier += .1;
      opacity -= ( 1.3 / framesPerSecond );
      circleRadius += ( 1000 / framesPerSecond );



  

      map.setPaintProperty('projects-pulse', 'circle-opacity', opacity)
      map.setPaintProperty('projects-pulse', 'circle-radius', circleRadius)

      if (opacity <= 1) {
        opacity = 1;
        circleRadius = 2;
      }

    }, 1000 / framesPerSecond );
  }

  pulseMarker(0);

})


  
  
</script>

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
 
    
    
    










  
    
    
    
    <script>

  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-SXCK9F16F5');
  
  
  
  let tg = window.Telegram.WebApp; //получаем объект webapp телеграма target="_blank"  

   tg.expand(); //расширяем на все окно  
  
</script>












<script src='https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.2/jquery.min.js'></script>


<script src='https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js'></script>







<script>
   
    $("[data-toggle='collapse']").on('click', function () {
      $("[data-toggle='collapse']").removeClass('current');
      $(this).addClass("current");
  $(this).toggleClass("oppened"); 
       $("[data-toggle='collapse']").not('.current').removeClass('oppened');
});



// Collapse accordion every time dropdown is shown
$('.dropdown-accordion').on('show.bs.dropdown', function (event) {
  var accordion1 = $(this).find($(this).data('accordion'));
  accordion1.find('.panel-collapse.in').collapse('hide');
  $("[data-toggle='collapse']").removeClass('oppened');
});

// Prevent dropdown to be closed when we click on an accordion link
$('.dropdown-accordion').on('click', 'a[data-toggle="collapse"]', function (event) {
  event.preventDefault();
  event.stopPropagation();
  $($(this).data('parent')).find('.panel-collapse.in').collapse('hide');
  $($(this).attr('href')).collapse('show');
  
});



// Close Nav When Link Is Selected
$('.panel-body a[href^="#section"], a[href^="#section"]').on('click', function(){
    $('.navbar-collapse').collapse('hide');
	$('.dropdown-toggle').click();
});


//Smooth Scrolling For Internal Page Links
$(function() {
  $('.list-group a[href*=#]:not([href=#]), a[href="#toTop"]').click(function() {
	if (location.pathname.replace(/^\//,'') == this.pathname.replace(/^\//,'') && location.hostname == this.hostname) {
	  var target = $(this.hash);
	  target = target.length ? target : $('[name=' + this.hash.slice(1) +']');
	  if (target.length) {
		$('html,body').animate({
		  scrollTop: target.offset().top
		}, 1000);
		return false;
	  }
	}
  });
});

</script>
    























<script>

map.on('load', function () {

  map.addLayer({
    'id': 'circle-one',
    'type': 'circle',
     'minzoom': 19,
    'source': {
      'type': 'geojson',
      'data': {
        "type": "FeatureCollection",
        "features": [
          {
            "type": "Feature",
            "properties": {},
            "geometry": {
              "type": "Point",
              "coordinates": [
                37.17403983330939, 55.97740800874055
              ]
          }
        }
      ]
    }
    },
    'layout': {},
    'paint': {
      'circle-radius': 8,
      'circle-color': '#3D85C6'
    }
  }, 'road-label-navigation');

  map.addLayer({
    'id': 'circle-two',
    'type': 'circle',
     'minzoom': 19,
    'source': {
      'type': 'geojson',
      'data': {
        "type": "FeatureCollection",
        "features": [
          {
            "type": "Feature",
            "properties": {},
            "geometry": {
              "type": "Point",
              "coordinates": [
                37.17403983330939, 55.97740800874055
              ]
          }
        }
      ]
    }
    },
    'layout': {},
    'paint': {
      'circle-opacity': 0,
      'circle-radius': 12,
      'circle-stroke-width': 2,
      'circle-stroke-color': 'white'
    }
  }, 'road-label-navigation');

  setInterval(function(){
      map.setPaintProperty('circle-one', 'circle-radius', 0);
      map.setPaintProperty('circle-two', 'circle-radius', 5);
      setTimeout(function(){
        map.setPaintProperty('circle-one', 'circle-radius', 9);
        map.setPaintProperty('circle-two', 'circle-radius', 8); }, 14);
  }, 500);

});

</script>














<script>

map.on('load', function () {

  map.addLayer({
    'id': 'circle-one1',
    'type': 'circle',
     'minzoom': 19,
    'source': {
      'type': 'geojson',
      'data': {
        "type": "FeatureCollection",
        "features": [
          {
            "type": "Feature",
            "properties": {},
            "geometry": {
              "type": "Point",
              "coordinates": [
                37.17399803571072, 55.97726678188010
              ]
          }
        }
      ]
    }
    },
    'layout': {},
    'paint': {
      'circle-radius': 8,
      'circle-color': '#3D85C6'
    }
  }, 'road-label-navigation');

  map.addLayer({
    'id': 'circle-two1',
    'type': 'circle',
     'minzoom': 19,
    'source': {
      'type': 'geojson',
      'data': {
        "type": "FeatureCollection",
        "features": [
          {
            "type": "Feature",
            "properties": {},
            "geometry": {
              "type": "Point",
              "coordinates": [
               37.17399803571072, 55.97726678188010
              ]
          }
        }
      ]
    }
    },
    'layout': {},
    'paint': {
      'circle-opacity': 0,
      'circle-radius': 12,
      'circle-stroke-width': 2,
      'circle-stroke-color': 'white'
    }
  }, 'road-label-navigation');

  setInterval(function(){
      map.setPaintProperty('circle-one1', 'circle-radius', 0);
      map.setPaintProperty('circle-two1', 'circle-radius', 5);
      setTimeout(function(){
        map.setPaintProperty('circle-one1', 'circle-radius', 9);
        map.setPaintProperty('circle-two1', 'circle-radius', 8); }, 14);
  }, 500);

});

</script>













<script>


      map.on('load', () => {
        map.addSource('trees', {
          'type': 'geojson',
          'data': 'https://raw.githubusercontent.com/EMIIA/www.emiia.ai/master/json/circlegeojson.geojson'
        });

        map.addLayer(
          {
            'id': 'trees-heat',
            'type': 'heatmap',
            'source': 'trees',
            
            'minzoom': 19,

            

            'paint': {
              // increase weight as diameter breast height increases
              'heatmap-weight': {
                'property': 'dbh',
                'type': 'exponential',
                'stops': [
                  [3, 0],
                  [3, 0]
                ]
              },
              // increase intensity as zoom level increases
              'heatmap-intensity': {
                'stops': [
                  [3, 0],
                  [3, 0]
                ]
              },
              // use sequential color palette to use exponentially as the weight increases
              'heatmap-color': [
                'interpolate',
                ['linear'],
                ['heatmap-density'],
                40,
                'rgba(293,209,234,80)',
                0.1,
                'rgb(103,169,207,80)',
                0.2,
                'rgb(166,189,219,80)',
                0.3,
                'rgb(103,169,207,80)',
                0.4,
                'rgb(28,144,153,80)'
                
            
              ],
              // increase radius as zoom increases
              'heatmap-radius': {
                'stops': [
                  [3, 2],
                  [3, 2]
                ]
              },
              // decrease opacity to transition into the circle layer
              'heatmap-opacity': {
                'default': 1,
                'stops': [
                  [3, 1],
                  [3, 0]
                ]
              }
            }
          },
          'waterway-label'
        );

        map.addLayer(
          {
            'id': 'trees-point',
            'type': 'circle',
            'source': 'trees',
            'maxzoom': 0,
            'paint': {
              // increase the radius of the circle as the zoom level and dbh value increases
              'circle-radius': {
                'property': 'dbh',
                'type': 'exponential',
                'stops': [
 [{ zoom: 2, value: 20 }, 100],

                ]
              },
              'circle-color': {
                'property': 'dbh',
                'type': 'exponential',
                'stops': [
                  [50, 'rgba(193,209,234,0.5)']


                ]
              },
              'circle-stroke-color': '#C1D1EA',
              'circle-stroke-width': 0.1,
            
           
              'circle-opacity': {
                'stops': [
                  [0, 0],
                  [3, 1]
                ]
              }
            }
          },
          'waterway-label'
        );
        
        
        map.setLayerZoomRange('trees-point', 0, 18);
        
      });

     
      
      
    </script>

















<script>    
       
       
       map.on('load', function() {
  map.addSource('clusters1', {
    type: "geojson",
    data: {
      "type": "FeatureCollection",
      "features": [
        {
          "type": "Feature",
          "geometry": {
            "type": "Point",
           
            "coordinates": [37.17417932268347,55.97743681787847]
          },
          "properties": {
              "emiia": "A"
            }
        }]
      }
    }
  );

  map.addLayer({
      "id": "clusters1",
      "type": "circle",
      "source": "clusters1",
'minzoom': 19,
      "paint": {
          "circle-radius": 18,
          "circle-color": "#3d85c6"
      }
  }, 'road-label-navigation');
  
  
  

  map.addLayer({
    "id": "clusters-label1",
    "type": "symbol",
    "source": "clusters1",
'minzoom': 19,
    "layout": {
      "text-field": "{emiia}",
      
  

      "text-font": [
 "DIN Offc Pro Medium",
        "Arial Unicode MS Bold"
      ],
      
     
      
      "text-size": 12
    },
    
    
    
  paint: {
    "text-color": "#ffffff"
  }
    
    
  }, 'road-label-navigation');
});
</script>
       
    
    
        
        
        
        









       
       
       
       
       
       
       
       
       
       
       
       
       
 <script>    
       
       
       map.on('load', function() {
  map.addSource('clusters', {
    type: "geojson",
    data: {
      "type": "FeatureCollection",
      "features": [
        {
          "type": "Feature",
          "geometry": {
            "type": "Point",
           
            "coordinates": [37.17400113045119,55.977360042089686]
          },
          "properties": {
          "color": "red",
              "emiia": "B"
            }
        }]
      }
    }
  );

  map.addLayer({
      "id": "clusters",
      "type": "circle",
      "source": "clusters",
'minzoom': 19,
      "paint": {
          "circle-radius": 18,
          "circle-color": "#3d85c6"
      }
  }, 'road-label-navigation');
  
  

  map.addLayer({
    "id": "clusters-label",
    "type": "symbol",
    "source": "clusters",
'minzoom': 19,
    "layout": {
      "text-field": "{emiia}",
      "text-font": [
        "DIN Offc Pro Medium",
        "Arial Unicode MS Bold"
      ],
      
      
     
      
      "text-size": 12,
         
    },
    
    
    
  paint: {
    "text-color": "#ffffff"
  }
    
    
    
    
  }, 'road-label-navigation');
});
</script>








    


</body>

</html>














